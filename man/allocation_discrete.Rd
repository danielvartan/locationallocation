% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/allocation_discrete.R
\name{allocation_discrete}
\alias{allocation_discrete}
\title{Compute the maximal coverage location-allocation for discrete problems}
\usage{
allocation_discrete(
  demand,
  bb_area,
  candidate,
  facilities = NULL,
  n_fac = Inf,
  n_samples = 1000,
  traveltime = NULL,
  mode = "walk",
  dowscaling_model_type = "lm",
  res_output = 100,
  weights = NULL,
  objectiveminutes = 15,
  objectiveshare = NULL,
  approach = "norm",
  exp_demand = 1,
  exp_weights = 1,
  par = FALSE
)
}
\arguments{
\item{demand}{A \code{\link[raster:raster]{RasterLayer}} object with the
demand layer (e.g. population density).}

\item{bb_area}{A \code{\link[sf:st_as_sf]{sf}} boundary box object with the area
of interest.}

\item{candidate}{A \code{\link[sf:st_as_sf]{sf}} object with the candidate
locations for the new facilities.}

\item{facilities}{A \code{\link[sf:st_as_sf]{sf}} object with the existing
facilities.}

\item{n_fac}{(optional) A positive \link[checkmate:checkIntegerish]{integerish}
number indicating the maximum number of facilities that can be allocated
(default: \code{Inf}).}

\item{n_samples}{(optional) A positive
\link[checkmate:checkIntegerish]{integerish} number indicating the number of
samples to generate in the heuristic approach for identifying the best set
of facilities to be allocated (default: \code{1000}).}

\item{traveltime}{A \code{\link[base:list]{list}} with the output of the
\code{\link[=traveltime]{traveltime()}} function. If not provided, the function will
run the \code{\link[=traveltime]{traveltime()}} function based on the provided
parameters.}

\item{mode}{(optional) A \code{\link[base:character]{character}} string indicating
the mode of transport. Options are \code{"fastest"} and \code{"walk"} (default =
\code{"walk"}).
\itemize{
\item For \code{"fastest"}: The friction layer accounts for multiple modes of
transport, including walking, cycling, driving, and public transport, and are
based on the Malaria Atlas Project (2019) \emph{Global Travel Speed Friction
Surface}.
\item For \code{"walk"}: The friction layer accounts only for walking speeds and is
based on the Malaria Atlas Project (2015) \emph{Global Walking Only Friction
Surface}.
}}

\item{dowscaling_model_type}{(optional) A \code{\link[base:character]{character}}
string indicating the type of model used for the spatial downscaling of the
friction layer. Options are \code{"lm"} (linear model) and \code{"rf"} (random
forest) (default: \code{"lm"}).}

\item{res_output}{(optional) A positive
\link[checkmate:checkIntegerish]{integerish} number indicating the spatial
resolution of the friction raster (and of the analysis), in meters. If the
resolution is less than \code{1000}, a spatial downscaling approach is used
(default: \code{100}).}

\item{weights}{(optional) A raster with the weights for the demand (default:
\code{NULL}).}

\item{objectiveminutes}{(optional) A number indicating the target travel time
in minutes used to compute the statistics (default: \code{15}).}

\item{objectiveshare}{(optional) A number indicating the proportion of the
demand to be covered by adding at most the number of facilities defined by
the \code{n_fac} parameter from the pool of candidate facilities
(default: \code{NULL}).}

\item{approach}{(optional) The approach to be used for the allocation.
Options are \code{"norm"} and \code{"absweights"}. If "norm", the allocation is based
on the normalized demand raster multiplied by the normalized weights
raster. If \code{"absweights"}, the allocation is based on the normalized demand
raster multiplied by the raw weights raster (default: \code{"norm"}).}

\item{exp_demand}{(optional) The exponent for the demand raster. Default is
\enumerate{
\item A higher value will give less relative weight to areas with higher
demand - with respect to the weights layer. This is useful in cases where
the users want to increase the allocation in areas with higher values in
the weights layer (default: \code{1}).
}}

\item{exp_weights}{(optional) The exponent for the weights raster. Default is
\enumerate{
\item A higher value will give less relative weight to areas with higher
weights - with respect to the demand layer. This is useful in cases where
the users want to increase the allocation in areas with higher values in
the demand layer (default: \code{1}).
}}

\item{par}{(optional) A \code{\link[base:logical]{logical}} flag indicating whether
to run the function in \link[parallel:clusterApply]{parallel} or not
(default: \code{FALSE}).}
}
\value{
A \code{\link[base:list]{list}} with the following elements:
\itemize{
\item \code{facilities}: A \code{\link[sf:sf]{sf}} object with the newly allocated
facilities.
\item \code{travel_time}: A \code{\link[raster:raster]{raster}} RasterLayer object
representing the travel time map with the newly allocated facilities.
\item \code{unmet_demand}: A \code{\link[base:numeric]{numeric}} value indicating the share
of demand that remains unmet after allocating the new facilities.
}
}
\description{
\code{allocation_discrete()} allocates facilities in a discrete location problem.
It uses the accumulated cost algorithm to identify optimal facility locations
based on the share of demand to be covered, given a user-defined set
of candidate locations and a maximum number of allocable facilities.

If a \code{objectiveshare} parameter is specified, the algorithm identifies the
best set of size of up to \code{n_fac} facilities to achieve the targeted coverage
share. The problem is solved using a statistical heuristic approach that
generates samples of the candidate locations (on top of the existing
locations) and selects the facilities in the one that minimizes the objective
function.

See \code{\link[=allocation]{allocation()}} for continuous location-allocation
problems.
}
\examples{
\dontrun{
  library(dplyr)

  allocation_data <-
    naples_population |>
    allocation(
      bb_area = naples_shape,
      facilities = naples_fountains,
      weights = naples_hot_day
    )

  allocation_data |> glimpse()

  allocation_data |> allocation_plot(naples_shape)
}
}
\seealso{
Other location-allocation functions: 
\code{\link{allocation}()}
}
\concept{location-allocation functions}
\keyword{location-allocation}
